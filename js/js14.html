<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>原型链</title>
</head>
<body>
    
    <script>

        /*
        
        1、Grand.prototype._proto_ = Object.prototype; 
            Object.prototype; // 是所有对象的最终原型

        2、对于XXX._proto_.原始值的属性值不能修改（只会在自己本身上加上这个原始值，不会在_proto_上改），只能引用值上增加或修改。
            son.money.card1 = 'abc';
            father.money.card1 // 输出 abc

            Grand.prototype._proto_ = Object.prototype; // 是所有对象的最终原型
            Grand.prototype.lastName = 'Deng';
            function Grand() {

            }

            var grand = new Grand();

            Father.prototype = grand;
            function Father() {
                this.name = 'xuming';
                this.money = {
                    card1: 'visa'
                }
            }

            var father = new Father();

            Son.prototype = father;
            function Son() {
                this.hobbit = 'smoke';
            }
            var son = new Son();

        3、this用法之一
            a.sayName()
            say.Name()里面this指向是，谁调用这个方法，this就是指向谁。

            Person.prototype = {
                name: 'a',
                sayName: function() {
                    console.log(this.name);
                }
            }
            function Person() {
                // this.name = 'b'; 有这一行就输出 b,没有就输出 a
            }
            var person = new Person();
            console.log(person.sayName()); 
            // 这个this就是指向person,就会先找person里面有没有这个属性，在找_proto_的

        4、对象最常用的就是 var obj = {}  ,写法简单

        5、另一种创建对象的方法
            // var obj = Object.create(原型); // 自己制定原型

            var obj = {name: 'sunny', age: 123};
            var obj1 = Object.create(obj);  // obj1的原型就是obj了

            （1）Object.create(null); // 没有原型

                var obj = Object.create(null);
                obj._proto_ = {name: 'sunny'};
                obj.name // 输出 undefined
                原型是隐式的内部属性，人为的加是不好使的。

            （2）所有的对象最终都会继承自 Object.prototype，除了Object.create(原型)外。
        
        6、undefined和null没有toString()属性，因为他们没有_proto_（原型）
            包装类
            原始值，没有属性，如果硬要给加上一个属性，它会经过包装类，但用完就立即销毁
                相当于没有，你可以访问，但都是undefined  除了length外
            var str = 'abcd';
            console.log(str.length);  // 输出 4

            str.length = 2;    // 经过包装类 new String(str.length = 2) 销毁
            console.log(str.length); // 输出4  相当于访问 new String(str.length)

            str.name = 'hello';  // new String(str.name = 'hello')  用完就销毁
            console.log(str.name); // 输出 undefined 相当于访问 new String(str.name)

            （1）var obj = 123;
                var obj1 = obj.toString();  // 会经过Number()包装类,一层一层向上访问Number.prototype --- > Object.prototype

            （2）undefined、null就是个原始值，没有包装类，也没有原型

            // var num = 123;
            // num.toString(); ---> new Number(num).toString();
            // Number.prototype.toString() = function () {}
            // Number.prototype._proto_ = Object.prototype
            // 因为Number自身有toString(),就会先访问自身的，虽然Object.prototype也有
            
        7、方法重写
            定义一个方法名相同，但实现不同功能，就是方法重写
            // Object.prototype是绝大多数对象的最终原型（还有一种对象创建是自定义原型的除外）。
            // Object.prototype.toString = function () {}
            Person.prototype = { // 覆盖Object.prototype.toString：方法的重写
                toString: function () {
                    return 'hehe';
                }
            }
            function Person() {

            }
            var person = new Person();

            (1)系统也会方法重写：
                // Object.prototype.toString
                Number.prototype.toString
                Array.prototype.toString
                Boolean.prototype.toString
                String.prototype.toString
            
            var obj = new Number(); // 有new才可以 ，不然直接调用 Number.prototype.toString
            obj.toString = function () {
                return 'asdf ';
            }
            document.write(obj);  // 输出 asdf ，调用的是自定义的toString

            var obj = new Number(); // 有 new才会进行创建隐式的this
            document.write(obj);   // 输出 0 ,调用的是 Number.prototype.toString

            var obj = new Number(5); // 有 new才会进行创建隐式的this
            document.write(obj);   // 输出 5 ,调用的是 Number.prototype.toString




        8、bug
            javascript有一个bug就是精度不准，有时候会发生小偏差，
            因此，javascript尽量避免小数操作，如果要有小数操作的话，尽量
            加Math.floor()   Math.ceil()  向下、向上取整

            例如： 0.14 * 100 = 14.000000000000002 这个就是精度不准造成的

            Math.ceil(123.12); // 输出 124  向上取整
            Math.floor(123.9999); // 输出 123 // 向下取整

            Math.random()  // 产生随机0~1的随机数，开区间的

            2e-15 = 2 * 10负15次方
            2e-16 = 2 * 10负16次方

            可正常计算的范围：小数点前十六位和后十六位，超过就自动忽略
            16位好使 1000000000000001 + 1000000000000001 = 2000000000000002
                    0.1000000000000001 + 0.1000000000000001 = 0.2000000000000002
            17位不好使 10000000000000001 + 10000000000000001 = 20000000000000000
                    0.10000000000000001 + 0.10000000000000001 = 0.2
        */
        
        var obj =  new Number(123); // 有new才可以 ，不然直接调用 Number.prototype.toString
           Number.prototype.toString = function () {
                return 'asdf ';
            }
            document.write(obj); 
        
        
    </script>

</body>
</html>